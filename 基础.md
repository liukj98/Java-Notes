# Table of Contents

- [概述](#概述)
   - [Java语言重大事件](#Java语言重大事件)
   - [Java语言的特点](#Java语言的特点)
   - [Java类的书写规范](Java类的书写规范)
   - [Java数据类型](#Java数据类型)
      - [整型](#整型)
      - [浮点型](#浮点型)
      - [字符型](#字符型)
      - [布尔型](#布尔型)
      - [探索赋值语句的底层原理](#探索赋值语句的底层原理)
   - [常量与变量](#常量与变量)
      - [常量](#常量)
      - [变量](#变量)
   - [类型转换](#类型转换)
      - [同种数据类型之间的转换](#同种数据类型之间的转换)
      - [不同数据类型之间的转换](#不同数据类型之间的转换)
   - [运算符号](#运算符号)
      - [算数运算符](#算数运算符)
      - [关系运算符](#关系运算符)
      - [赋值运算符](#赋值运算符)
      - [逻辑运算符](#逻辑运算符)
      - [位运算符](#位运算符)
      - [条件运算符](#条件运算符)
      - [instanceof运算符](#instanceof运算符)
- [面试难点](#面试难点)
   - [自增与自减运算符](#自增与自减运算符)
   - [原码、反码、补码](#原码、反码、补码)
   - [0.1+0.2==0.3?](#0.1+0.2==0.3?)
   - [如何将两个变量的值进行转换](#如何将两个变量的值进行转换)
      - [方式一](#方式一)
      - [方式二](#方式二)
      - [方式三](#方式三)
## 概述

### Java语言重大事件

1. **1995 正式发布**

2. **1996 正式发布了可以下载的 JDK 工具包 JDK 1.0**

3. 1999 发布**第二代 Java 平台**，简称 **JDK1.2**，细化三个不同的版本

   | 版本       | 英文名                 | 简称     |
   | ---------- | ---------------------- | -------- |
   | **标准本** | **Standard Edition**   | **J2SE** |
   | **企业版** | **Enterprise Edition** | **J2EE** |
   | **微型版** | **Micro Edition**      | **J2ME** |

4. 2004 JDK1.5 版本，添加了很多特性，比如 `for-each 循环、泛型等`，同时 JDK1.5 改名为 JavaSE5.0
5. 2005 JDK6 版本
   
6. 2009 Oracle 公司以 `74亿$` 收购了 SUN 公司

### Java语言的特点

![](https://cdn.jsdelivr.net/gh/liukj98/image-hosting@master/Java学习图片资源/image-20210915121629732.5ihjrcc8v9c0.png)

![](https://cdn.jsdelivr.net/gh/liukj98/image-hosting@master/Java学习图片资源/image-20210920191357343.6bq4nadonrw0.png)

1. **跨平台性**

   所谓的**跨平台**，就是一套代码可在不同的操作系统上运行。

   现在思考一个问题：**为什么它能够实现跨平台呢？**

   答：因为有一个东西，叫做 JVM(Java Virtual Machine) Java 虚拟机，Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

   现在再来思考一个问题：以 `.class` 结尾的文件（字节码文件）可以直接在计算机上运行吗？

   答：不能。因为一个文件要想运行，它需要对应的运行环境，比如：`.doc` 文件需要 office 办公软件、`.txt` 文件需要记事本打开等。所以 `.class` 文件要想运行它也得要有一个对应的运行环境，这个运行环境就是 JRE(Java Runtime Enviroment)

   在 Java 中， **JRE 包含了 JVM**

   而作为开发人员，仅仅有 JRE 肯定是不行的，因为 JRE 只是一个运行环境，它并不附带能够开发 Java 源代码的能力，所以我们需要有一个东西（工具）能够帮助我们进行 Java 源代码的开发，这个工具就是 JDK(Java Development Kit)。而现实中我们只需要下载 JDK 就可以了，因为 **JDK 中包含了 JRE，JRE 中又包含了 JVM**

   > 关于 JDK 下载地址 ，[请点击我](https://www.oracle.com/java/technologies/javase-downloads.html)

2. 面向对象

3. 简单性

4. 健壮性（鲁棒性）

   异常处理、垃圾回收等

5. 大数据开发相关

### Java类的书写规范

```java
// Demo.java
public class Demo {
  public static void main(String[] args) {
    System.out.println("hello");
  }
}
```

当你在类名前加了一个权限修饰符 `public` 时，类名要与文件名一致。如上，我写了一个 public 类 Demo，那么该文件名就必须是 Demo.java，否则  JVM 在编译时就会报错

一个 `.java` 文件中至多有一个公共类

### Java数据类型

**基本数据类型（8个）**

| 类型    | 占用字节数/byte | 所属类型      |
| ------- | --------------- | ------------- |
| byte    | 1               | 整型-字节型   |
| short   | 2               | 整型-短整型   |
| int     | 4               | 整型          |
| long    | 8               | 整型-长整型   |
| float   | 4               | 浮点型-单精度 |
| double  | 8               | 浮点型-双精度 |
| char    | 2               | 字符型        |
| boolean | $\frac{1}{8}$   | 布尔类型      |

**引用数据类型**

1. 数组
2. 类
   1. 抽象类
   2. 接口
3. 注解，相当于 JavaScript 中的装饰器

**包装类**

#### 整型

1. **字节型（byte）**
2. **短整型（short）**
3. **整型（int）**
4. **长整型（long）**

以 `byte` 类型为例，占 `1个` 字节（8bit），即 `0 0000000`，共有 **256种** 组合。其中第一位表示符号位，`0` 表示正数，`1` 表示负数，范围为 **-128 ~ 127**。其它整型类似

`short` 类型，占 `2个` 字节（16bit），即 `0 000000000000000`，共有 **512种** 组合。其中第一位表示符号位，`0` 表示正数，`1` 表示负数，范围为 **-256 ~ 255**

#### 浮点型

1. **单精度浮点型（float）**

   书写：值后跟 f 或 F，如 `float f = 12.3F;`
   因为小数在常量池中默认是以双精度（double）进行存储的，你若直接将一个双精度的值赋值给一个单精度的变量，这在编译时是会报错的。

   而当你在小数后跟一个 f 或 F，编译器会作进一步的处理：将双精度的值以单精度进行存储

2. **双精度浮点型（double）**

   书写：`double d = 12.4;`

#### 字符型

1. **char**

   书写：英文单引号，如 `char c = '9';`

   占 2个 字节，使用 Unicode 编码

#### 布尔型

1. **boolean**

   书写：`boolean flag = true;`

   占 1 bit

#### 探索赋值语句的底层原理

> 本质是 Java 程序在内存中是如何分布的（需要深入理解 JVM 啦）

以 `byte a = 33;` 为例

![](https://cdn.jsdelivr.net/gh/liukj98/image-hosting@master/Java学习图片资源/image-20210829201041616.1nbb17ekc9uo.png)

上述赋值语句执行过程分析：

1. 在存储区的常量池中存储 `33` 常量，并且该常量值是以 32bit 进行存储的
2. 在栈内存中开辟一个 byte 类型的内存空间，大小为 8bit，空间的名称为 a
3. 然后从常量池中取出 `33` 赋值给 a 变量，但是在赋值的过程中会发生这样一个情况
   1. 从常量池中取出的 `33` 是 32bit 的，而赋值的变量是 8bit 的，按理来说，如果将 32bit 的值赋给 8bit 的变量是不可以的，但是由于 java 编译器底层做了一些处理，使得其可以完成赋值而不报错

### 常量与变量

#### 常量

表示在程序运行过程中不能改变的值

基本类型的值都可以认为是常量，如 4、3.4、'a'、true 等

常量存储在常量缓冲区（常量池）中，有且只有一份

常量池中的值默认空间大小有两种：32bit、64bit，32bit 用于存储 int 类型，64bit 用于存储 double 类型

#### 变量

变量指的是 在程序运行过程中可以改变的

变量是一个内存空间（容器）

变量在创建的时候必须指定数据类型，以及变量空间的名字

变量空间里的内容是可以改变的

### 类型转换

> 任何一个数据最终都是以二进制的形式呈现给计算机进行**读**和**取**
>
> 不同数据类型之间的转换本质是看要转换的俩方在计算机底层上的**二进制位数**以及**精确程度**
>
> 布尔类型很特殊，不能与其他基本数据类型发生转化

#### 同种数据类型之间的转换

直接进行赋值操作即可

```java
byte a = 99;
byte c = a;

int num1 = 88;
int num2 = num1;

float a = 12.8F;
float b = a;
```

#### 不同数据类型之间的转换

- 「整型与整型」 或 「浮点型与浮点型」
  
  > 比较的是**内存空间大小**
  
  - 小数据类型赋值给大数据类型，直接进行
  
  ```java
  // 整型与整型
  byte a = 9;
  int b = a;
  
  // 浮点型与浮点型
  float f = 12.3F;
  double d = f;
  ```
  
  - 大数据类型赋值给小数据类型，需要进行指定，该过程也称为**强制类型转换**
  
  ```java
  // 整型与整型
  int a = 9;
  byte b = (byte)a; // 强制类型转换
  
  // 浮点型与浮点型
  double d = 12.3;
  float f = (float)d; // 强制类型转换
  ```
  
- 整型与浮点型

  > 比较的是**精确程度**

  它们俩之间的转换比较的是**精确程度**，浮点型的精确程度更高，所以由**整型（低精确度）**可直接转化成**浮点型（高精确度）**，而由浮点型**（高精确度）**转换为整型**（低精确度）**需要进行强制类型转换
  
  ```java
  // 浮点型转换为整型
  float f = 11.2F;
  long b = (long)f; // 强制类型转换
  
  // 整型转换为浮点型，直接转换
  long a = 99;
  float f = a;
  ```

- 整型与字符型

  ```java
  int a = 99;
  char b = (char) a;// 强制类型转换
  
  char a = '我';
  int b = a;
  ```

### 运算符号

#### 算数运算符

1. 加：`+`
2. 减：`-`
3. 乘：`*`
4. 除：`/`
5. 求余：`%`
6. 自增：`++`
7. 自减：`--`

#### 关系运算符

1. 大于：`>`
2. 大于等于：`>=`
3. 小于：`<`
4. 小于等于：`<=`
5. 等于：`==`
6. 不等于：`!=`

#### 赋值运算符

1. `=`
2. `+=`
3. `-=`
4. `*=`
5. `/=`
6. `%=`

#### 逻辑运算符

1. 逻辑与：`&`
2. 逻辑或：`|`
3. 逻辑非：`!` ✅
4. 短路与：`&&` ✅
5. 短路或：`||` ✅

#### 位运算符

1. 按位与：`&`
2. 按位或：`|`
3. 按位取反：`~`
4. 按位异或：`^`
5. 左移：`<<`
6. 右移：`>>`
7. 无符号右移：`>>>`

#### 条件运算符

**也称为三目运算符**

1. `?:`

#### instanceof运算符

## 面试难点

### 自增与自减运算符

```java
int a = 1;
a = a++;
System.out.println(a);
```

> `++` 自增运算符属于算数运算符，一般算数运算符的优先级大于赋值运算符优先级
>
> **以上述代码为例**
>
> 1. `++` 在后，计算机底层会先对 a 变量进行备份，然后将 a 变量的值加1（不是备份的变量哦），最后将备份变量的值符给 a 变量，然后备份空间被销毁
>
> 2. 若 `++` 在前，计算机底层会先对 a 变量进行加1，然后对 a 变量进行备份，最后将备份变量的值符给 a 变量，然后备份空间被销毁
>
> 所以无论 `++` 在前还是在后，最终赋值给 a 变量的都是**备份中的值**

了解上述 `++` 运算符原理后再来看一个面试题，最终输出多少？

```java
int a = 1;
for (int i = 0; i < 100; i++) {
  a = a++;
}
System.out.println(a);// 1
```

### 原码、反码、补码

正数的原码、反码、补码相同

负数的反码相对于原码符号位不动，其余位取反，补码相对于反码加1

以十进制 `6` 和 `-6` 为例，它们的原码、反码、补码如下

|      | 6                                   | -6                                  |
| ---- | ----------------------------------- | ----------------------------------- |
| 原码 | 00000000 00000000 00000000 00000110 | 10000000 00000000 00000000 00000110 |
| 反码 | 00000000 00000000 00000000 00000110 | 11111111 11111111 11111111 11111001 |
| 补码 | 00000000 00000000 00000000 00000110 | 11111111 11111111 11111111 11111010 |

**计算机中不管是正数还是负数，都是以补码的形式进行存储的**

**我们现在思考一个问题：为什么要用补码的方式表示数字，而不用原码（直接转换的二进制数字）表示呢？**

答：比如做这种运算 `-2 + 1 = ?` 时，若直接将十进制数字转换成二进制数字进行运算就会发生错误，如果采用补码的方式进行运算就不会了。你可以自己先转换成二进制试一试，再转换成补码的形式试试就明白了。所以，计算机之所以用补码的形式表示数字，就是为了数字间计算方便



了解上述内容之后，再去学习 `按位与(&)`、`按位或(|)`、`按位异或(^)`、`左移(<<)`、`右移(>>)、无符号右移(>>>)` 等位运算就很容易了

### 0.1 + 0.2 == 0.3 ? 

**要想解决这个问题，你需要掌握如下知识：**

1. 如何将十进制数转换成二进制数？
2. 如何用科学计数法表示二进制数？
3. 计算机中是如何表示二进制数的？

![](https://cdn.jsdelivr.net/gh/liukj98/image-hosting@master/Java学习图片资源/image-20210915123806419.5cp3mclm2jk0.png)

### 如何将两个变量的值进行转换

以 `int a = 1; int b = 2;` 为例

#### 方式一

分析：利用了一个额外的存储空间，效率不是很高 ❌

```java
int a = 1;
int b = 2;
int c = a; // 在栈内存中开辟一个额外的内存空间，空间变量名为 c
a = b;
b = c;
```

#### 方式二

分析：不需要额外的空间，效率相对于**「方式一」**要高点，但是可能会发生空间越界，原因是 `a+b` 的值可能超过 int 类型的值范围

```java
int a = 1;
int b = 2;
a = a + b; 
b = a - b; // b = (a + b) - b = a
a = a - b; // (a + b) - a = b
```

#### 方式三

分析：利用 `异或（^）` 运算符，效率最高。异或运算规则：相同数进行 `异或` 为 0，不同数进行 `异或` 为 1。所以，相同的数进行异或一定为0，然后再与 `另外一个数` 进行异或，其结果一定等于 `另外一个数`，也就是 `a^b^b` 一定等于 `a`

```java
int a = 1;
int b = 2;
a = a^b;
b = a^b; // 等价于 b = (a^b)^b = a^b^b = a;
a = a^b; // 等价于 a = (a^b)^a = a^b^a = b;
```

## 语法结构（流程控制）

### 顺序结构

### 分支结构

#### 单分支 if

#### 多分支 switch

### 循环结构

#### for 循环

#### while 循环

#### do while 循环

## 数组

### 数组的定义

1. **形式：**

   **数据类型[] 数组名**

   也可以是 **「数据类型 []数组名」** 或 **「数据类型 数组名[]」** 的形式

   但是一般来说，我们采用正规的写法进行数组的定义，即 `数据类型[] 数组名`

```java
int[] arr = {1, 2, 3}
int []arr = {1, 2, 3}
int arr[] = {1, 2, 3}
// 以上三种方式结果都是一样的，但一般我们都是采用的第一种方式进行数组的定义
```

2. **举例：**

```java
int[] arr
char[] arr1
boolean[] arr2 
String[] arr3
```

### 数组的赋值（初始化）

#### 静态初始化

有长度，有元素

```java
// 方式一
int[] arr = {1, 2,4, 9, 7};

// 方式二
// 当你通过 new 的方式创建一个对象时，在堆内存中会申请开辟了一个块新的空间
int[] arr = new int[]{3, 9, 4, 1, 7};
```

#### 动态初始化

有长度，没有元素，但是会有默认值，不同的元素类型其默认值是不一样的

```java
int[] arr = new int[5]; // 创建一个长度为5的整型数组，默认值为 0
float[] arr = new float[5]; // 默认值为 0.0
String[] arr = new String[5]; // 默认值为 null
```

### 数组的访问

通过 `index` 索引进行访问，`index` 从 `0` 开始计数 

### 其它

所有的变量空间都存储在栈内存中

变量空间可以存储基本数据类型，也可以存储引用数据类型

如果变量空间存储的是基本数据类型，则存储的是**值**

如果变量空间存储的是引用数据类型，则存储的是**引用（地址）**

增强的 for：`for-each`

```java
// 形式
for(数据类型 变量名: 数组变量){
  System.out.println(变量名)
}
// 比如
public static void main(String[] args){
  int[] arr = {3, 9, 4, 1, 2};
  for(int t: arr){
    System.out.println(t);
  }
}
```

## 面向对象

### 属性

**形式**

```java
// [] 括号里的内容不是必填的
权限修饰符 [特征修饰符] 数据类型 属性名字 [= 值]； 
  
// 
public String name;
```

### 方法

> **特殊的方法： `main` 方法**
>
> 它是专属于虚拟机用于启动应用程序所存在的一个特殊的静态方法

**形式**

```java
// [] 括号里的内容不是必填的
权限修饰符 [特征修饰符] 返回值类型 方法名字 (参数列表) [抛出异常] [{
	方法体
}]
  
权限修饰符 返回值类型 方法名字 (参数列表){
	方法体
}

// 
public void sayHello(){
  System.out.println("hello world");
}
```

**方法重载**：具有相同的方法名，不同的参数列表

**JDK1.5 版本之后出现了一个新的语法：动态参数列表。**该**动态参数列表**类似于 javascript 中的**剩余参数**

```java
// x 本质是一个数组
public void test(int... x){
  for(int a: x){
    System.out.println(a)
  }
}
```

### 构造器

**形式**

```java
// [] 括号里的内容不是必填的
权限修饰符 方法名字即为类名 (参数列表) [抛出异常] [{
	方法体;
}]
```

每个类中默认都有一个构造方法，若没有写构造方法，默认会提供一个无参的构造方法；若你自己写了构造方法，则会覆盖默认的构造方法

构造方法也存在方法重载，我们把它称之为**构造方法重载**

构造方法的主要功能就是进行**初始化**

### 程序块

1. **写法**：一对大括号包裹 `{}`

```java
// 比如
public class Demo {
  // 程序块
  {
    System.out.println("我是程序块");
  }
  
  public static void main(String[] args) {
    Demo d = new Demo();
  }
}
```

2. **执行时机**：每一次我们调用构造方法之前，系统会帮我们自动地调用一次程序块

3. **静态代码块**：在程序块前添加 static 特征修饰符


### this 关键字

**用来代替某一个对象**

1. 在一个构造方法中调用另一个构造方法，通过 `this()` 形式，并且要放在第一行
2. 在构造方法（或普通方法）中调用属性或方法，通过 `this.属性名` 或 `this.方法名()` 形式

## 注解（Annotation）

### 理解注解

1. **注解（Annotation）**是从 JDK5.0 开始引入的一个新技术

2. **注解的作用**
   1. 注解并不是程序本身，但却可以对程序作出解释，解释的内容也称之为元数据
   2. **注解可以被其它程序读取**

3. **注解的书写格式**

   以 `@注释名` 的格式在代码中存在

4. **注解可以在哪里使用**

   可以附加在 `package`、`class`、`method`、`field` 等上面，相当于给它们添加了额外的辅助信息。我们可以通过反射机制编程实现对这些元数据的访问

5. **JAVA 中的注解类似于 TypeScript 中的装饰器**

### 内置注解

常见的内置注解有下面三种

1. **@Override**

   定义在 java.lang.Override 中，此注解只能用于修饰方法。表示要重写超类的一个方法

2. **@Deprecated**

   定义在 java.lang.Deprecated 中，此注解可以用于修饰属性、方法、类。表示不鼓励程序员使用被修饰的元素

3. **@SuppressWarnings**

   定义在 java.lang.SuppressWarnings 中，用于抑制编译时的警告信息

   与前两个注解不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性地使用即可，比如：

   `@SuppressWarnings("all")`

   `@SuppressWarnings("unchecked")`

   `@SuppressWarnings(value={"unchecked", "deprecated"})`

### 元注解

元注解的作用就是负责注解其它注解（也称为**注解的注解**），Java 中定义了4个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型的说明

这些类型和它们所支持的类可以在 java.lang.annotation 包中找到

1. **@Target**

   用于描述注解的使用范围

2. **@Retention**

   表示需要在什么级别使用保存该注解信息，用于描述注解的生命周期

3. **@Document**

   说明该注解将包含在 javadoc 中

4. **@Inherited**

   说明子类可以继承该父类中的注解 

定义一个注解：`[public] @interface 注解名`

```java
// 使用元注解
// 
@Target(value = ElementType.METHOD)
@interface MyAnnotation{
  
}
```

### 自定义注解

自定义注解格式：`[public] @interface 注解名{定义内容}`

使用 @interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口

当注解的 `定义内容` 中有 `value` 字段，在使用注解时传递的参数可以不写 `value`， 直接写参数值即可，例子如下

```java
public class Demo {
  @MyAnnotation2("hello")
  @MyAnnotation(name = "lkj")
  public void test(){
    System.out.println("使用了自定义注解");
  }
}

/**
 * 定义一个注解 MyAnnotation，该注解只能在方法上使用
 * 该注解需要传递一个 name 参数，如果没有传递，默认为 ""
 */
@Target(ElementType.METHOD)
@interface MyAnnotation{
  String name() default "";
}
/**
 * 定义一个注解 MyAnnotation2，该注解只能在方法上使用
 * 该注解需要传递一个 value 参数
 */
@Target(ElementType.METHOD)
@interface MyAnnotation2{
  String value();
}
```

## 反射（Reflection）

### 理解反射

反射是 java 被视为动态语言的关键，反射机制允许程序在执行期间借助 Reflection API 取得任何类的内部消息，并能直接操作任意对象的内部属性和方法

加载完类后，在堆内存的方法区中就产生了一个 Class 类型的对象（**一个类只有一个 Class 对象，并且 Class 对象不是我们 new 出来的，是类加载器（ClassLoader）加载出来的**），这个对象就包含了完整的类的结构信息，因此我们可以通过这个对象看到类的结构。换言之，这个对象就像一面镜子，透过这个镜子可以看到类的结构，所以，我们也形象的称之为**反射**

反射之所以被称为框架的灵魂，主要是因为它赋予了我们**在运行时分析类以及执行类中方法**的能力。

**正常方式**

1. 引入需要的包类名称  
2. 通过 new 实例化
3. 取得实例化对象

**反射方式**

1. 取得实例化对象
2. 调用 getClass() 方法
3. 取得完整的包类名称

### 优缺点

#### 优点

可以实现动态创建对象和编译，体现出很大的灵活性

#### 缺点

**对性能有影响**。使用反射基本上是一种解释操作，我们可以告诉 JVM ，我们希望做什么并且满足我们的要求。这类操作总是慢于直接执行相同的操作。

### 反射相关类

#### java.lang.Class

#### java.lang.reflect.Field

#### java.lang.reflect.Method

#### java.lang.reflect.Constructor

### 获取 Class 类对象

1. **前提**：已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName() 获取，可能抛出 ClassNotFountException 异常。

   **实例**：Class cls = Class.forName("java.lang.Cat");

   **应用场景**：多用于配置文件，读取类全路径，加载类

2. **前提**：若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。

   **实例**：Class cls = Cat.class;

   **应用场景**：多用于参数传递，比如通过反射，得到对应构造器对象

3. **前提**：已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象。

   **实例**：Class cls = 对象.getClass();

   **应用场景**：通过创建好的对象，获取 Class 对象

4. 其它方式：通过类加载器（4种）

   ClassLoader cl = 对象.getClass().getClassLoader();

   Cl.loadeClass(类的全路径);

5. **基本数据类型**的 Class 类对象

   Class cl = 基本数据类型.class;

6. **包装数据类型**的 Class 类对象

   Class cl = 包装数据类型.TYPE;

```java
Class<?> aClass = Class.forName("basicNode.TreeNode");
System.out.println("第一种方式获取 Class 对象：" + aClass);

Class<TreeNode> treeNodeClass = TreeNode.class;
System.out.println("第二种方式获取 Class 对象：" + treeNodeClass);

TreeNode treeNode = new TreeNode(12);
Class<? extends TreeNode> aClass1 = treeNode.getClass();
System.out.println("第三种方式获取 Class 对象：" + aClass1);

ClassLoader classLoader = aClass1.getClassLoader();
Class<?> aClass2 = classLoader.loadClass("basicNode.TreeNode");
System.out.println("第四种方式获取 Class 对象：" + aClass2);

Class<Integer> integerClass = int.class;
System.out.println("基本数据类型的 Class 对象：" + integerClass);

Class<Boolean> type = Boolean.TYPE;
System.out.println("包装数据类型的 Class 对象：" + type);
```

### 哪些类型有 Class 对象

1. 类
2. 接口（interface）
3. 数组
4. 枚举（enum）
5. 注解（annotation）
6. 基本数据类型
7. void

```java
Class<String> stringClass = String.class;// 普通类
Class<Serializable> serializableClass = Serializable.class;// 接口
Class<Integer[]> aClass = Integer[].class;// 数组
Class<Deprecated> deprecatedClass = Deprecated.class;// 注解
Class<Thread.State> stateClass = Thread.State.class;// 枚举
Class<Void> voidClass = void.class;// void
Class<Class> classClass = Class.class;// Class
```

### 类加载

反射机制是 java 实现动态语言的关键，也就是通过反射来实现类的**动态加载**

1. 静态加载：编译时加载相关的类，如果没有，则报错，依赖性太强
2. 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性。反射就是采用了这种加载方式

类加载的时机

1. 当通过 new 的方式创建对象时。属于静态加载
2. 当子类被加载时，父类也被加载。属于静态加载
3. 调用类中的静态成员时。属于静态加载
4. **通过反射。属于动态加载**

## 权限（访问）修饰符

在 java 中，一个类中的哪些字段可以被哪些访问修饰符所修饰呢？首先，java 中常见的字段有**「类本身」**、**「嵌套类」**、**「构造器」**、**「方法」**、**「属性」**。其中有一个字段很特殊，就是 **Class（类本身）**只能应用 **default** 和 **public** 这两个访问修饰符，其它字段都可以被所有访问修饰符所修饰。同时 interface（接口）也只能应用 **default** 和 **public** 这两个访问修饰符，如下表格

|              | private | default | protected | public |
| ------------ | ------- | ------- | --------- | ------ |
| Class        | **No**  | Yes     | **No**    | Yes    |
| Nested Class | Yes     | Yes     | Yes       | Yes    |
| Constructor  | Yes     | Yes     | Yes       | Yes    |
| Method       | Yes     | Yes     | Yes       | Yes    |
| Field        | Yes     | Yes     | Yes       | Yes    |

这四个访问修饰符在的应用权限如下

|           | 同类 | 同包 | 子类 | 不同包 |
| --------- | ---- | ---- | ---- | ------ |
| public    | ✅    | ✅    | ✅    | ✅      |
| protected | ✅    | ✅    | ✅    | ❌      |
| default   | ✅    | ✅    | ❌    | ❌      |
| private   | ✅    | ❌    | ❌    | ❌      |

## 特征修饰符

### final

#### 什么情况下要使用 final 关键字

1. **修饰某个类时，表示该类不可以被继承**
2. **修饰某个方法时，表示该方法不可以被重写**
3. 修饰类中的某个属性时，表示该属性不可以被修改
4. 修饰局部变量时，表示该局部变量不可以被修改
   1. 如果修饰的变量是**基本数据类型**，则变量的值不可更改
   2. 如果修饰的变量是**引用数据类型**，则变量的地址（内存地址）不可更改，但地址空间内的数据可以更改

#### final 关键字使用的一些小细节

1. final 修饰的属性也称为常量，一般用大写字母表示
2. final 修饰的属性在定义时必须初始化，并且以后不能再修改。初始化的位置可以有
   1. 在属性定义时，如：`public final double PI = 3.14;`
   2. 在构造函数中
   3. 在代码块中

3. 如果 final 修饰的属性是静态的，则初始化的位置只能是
   1. 定义时
   2. 静态代码块中

4. 如果类不是 final 类，但是含有 final 方法，虽然该方法不能被重写，但是可以被继承
5. 一般来说，如果一个类已经是 final 类了，就没有必要将该 final 类中的方法也修饰成 final
6. **final 不能修饰构造函数**
7. final 和 static 往往搭配使用，效率更高，因为**不会导致类加载**。
8. Integer 等包装类、String、Math 等多数工具类都是 final 类

### static

#### 可以修饰什么

1. 修饰属性
2. 修饰方法
3. 修饰块
4. 修饰类（内部类）

#### 修饰的内容有什么特点

1. 被 static 修饰的内容在类加载时就初始化了，**创建的时期非常早**
2. 静态元素存储在静态元素区中，每一个类都有一个自己的这样的区域
3. 静态元素只加载一次，被类对象和类本身共享

### abstract

### native

### transient

### synchronnized

### volatile



## 常用的工具类

### Object 类

#### == 运算符

1. 既可以判断基本数据类型，也可以判断引用数据类型
2. 当判断基本数据类型时，比较的是值是否相等，如：int i = 10; double d = 10.0
3. 当判断引用数据类型时，比较的是对象的**地址（内存地址）**是否相同

#### equals 方法

```java
// Object 中的 equals 方法
public boolean equals(Object obj) { // 判断地址是否相同
    return (this == obj);
}
```

1. 由于 equals 是 Object 类中的方法，所以它只能应用于引用数据类型之间的判断
2. 默认判断地址是否相同，Object 的子类中往往重写该方法用于判断内容是否相同，比如 Integer、String 类等
3. 当然，你也可以在自己的类中重写 equals 方法

#### equals 与 == 面试题

```java
// 代码题一
Person person1 = new Person();
person1.name = "lkj";
Person person2 = new Person();
person2.name = "lkj";

System.out.println(person1 == person2); // false
System.out.println(person1.name.equals(person2.name)); // true
System.out.println(person1.equals(person2)); // false

String str1 = new String("henry");
String str2 = new String("henry");

System.out.println(str1.equals(str2));// true
System.out.println(str1 == str2);// false

class Person{
  public String name;
}

// 代码题二
int it = 65;
float fl = 65.0f;
System.out.println("65 和 65.0f 是否相等？" + (it == fl));// T
char ch1 = 'A';
char ch2 = 12;
System.out.println("65 和 'A' 是否相等？" + (it==ch1));// T
System.out.println("12 和 ch2 是否相等？" + (12 == ch2)); // T

String str1 = new String("hello");
String str2 = new String("hello");
System.out.println("str1 和 str2 是否相等？" + (str1 == str2));// F

System.out.println("str1 是否 equals str2？" + str1.equals(str2));// T
```

#### hashCode

```java
@HotSpotIntrinsicCandidate
public native int hashCode();
```

它是一个 native 方法（本地方法），native 方法会交由 java 虚拟机实现（调用时放入 `本地方法栈` 中），开发人员不需要关心

1. 提高具有哈希结构的容器效率
2. 两个引用如果指向的是同一个对象，则哈希值肯定相同
3. 两个引用如果指向的是不同对象，则哈希值一般不同（因为有可能发生哈希碰撞导致哈希值相同，但这种概率极小，取决于设计的哈希算法）
4. 哈希值主要由**地址号（内存地址）**来决定，但不能完全等同于地址号

#### toString

```java
// getClass().getName() 表示获取全类名(包名+类名)
// Integer.toHexString(hashCode()) 将该类的 hashCode 值转为十六进制表示
public String toString() {
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

1. 默认返回 `全类名+@+哈希值的十六进制`
2. 子类往往会重写 toString 方法，用于返回对象的属性信息
3. 当直接输出一个对象时，toString 方法会被默认的调用。也就是说 `System.out.println(obj);` 等价于 `System.out.println(obj.toString());`

### 字符串相关的类

#### String

> String: 不可变的字符序列。底层使用 char[] 存储 
>
> StringBuffer: 可变（说明有**扩容机制**）的字符序列。线程安全，效率低，底层使用 char[] 存储
>
> StringBuilder: 可变（说明有**扩容机制**）的字符序列。JDK5.0 新增的，线程不安全，效率高，底层使用 char[] 存储

**理解 String，什么是「不可变性」**

1. String 类型声明为 final，表示不可继承
2. String 实现了 Serializable 接口、Comparable 接口，表示字符串是支持序列化的、可以比较大小的
3. String value 声明为 `privete final byte[]`， 表示字符串长度不可变
4. String 代表不可变的字符序列。简称：**不可变性**。体现在
   1. 当对字符串重新赋值时，需要给另外的内存区域赋值，再将此区域中的值赋值给该变量，不能使用原有内存中的 value 进行赋值
   2. 当对现有字符串进行拼接操作时，也需要给另外的内存区域赋值，再将此区域中的值赋值给该变量
   3. 当调用 String 的 replace 方法修改指定字符或字符串时，也需要重写指定另外的内存区域再赋值

**String 实例化方式**

1. 通过字面量形式

```java
// 此时的变量 s1、s2 的数据 "hello" 保存在方法区的字符串常量池中，并且只有一份
String s1 = "hello";
String s2 = "hello";
```

2. 通过 `new` 的形式

```java
// 此时的变量 s1、s2 的数据 "hello" 保存在堆内存中，并且是两份不同的数据，尽管都是字符串 "hello"
// 因为每次通过 new 创建对象时都会在堆内存中开辟一个新的空间，所以 s1、s2 变量保存的是两个不同的堆内存空间地址
String s1 = new String("hello");
String s2 = new String("hello");
```

**面试题：String s = new String();方式创建对象，在内存中创建了几个对象？**

答：两个：一个是堆内存中的 new 结构，另一个是 char[] 对应的常量池中的数据

**字符串拼接**

1. 常量与常量的拼接结果在常量池中，且常量池中不会存在内容相同的常量
2. 只要其中有一个是变量，结果就在堆中
3. 如果拼接的结果调用 intern() 方法，其返回值就在常量池中

```java
String s1 = "hello";
String s2 = "world";
String s3 = "helloworld";
String s4 = "hello" + "world";
String s5 = s1 + "world";
String s6 = "hello" + s2;
String s7 = s1 + s2;
System.out.println(s3 == s4); // true
System.out.println(s3 == s5); // false
System.out.println(s3 == s6); // false
System.out.println(s3 == s7); // false
System.out.println(s5 == s6); // false
System.out.println(s6 == s7); // false
String s8 = s7.intern();
System.out.println(s8 == s3); // true
```

**一道面试题**

```java
public class App {
  String s = new String("te st");
  char[] c = {'t', 'e', 's', 't'};

  public void change(String str, char[] c){
    str = "exit";
    c[0] = 'b';
  }
  public static void main(String[] args) {
    App app = new App();
    app.change(app.s, app.c);
    System.out.println(app.s);// test
    System.out.println(app.c);// best
  }
}
```

**String 与其它数据类型间的转换**

1. String 与数字

```java
String s = "123";
int i = Integer.parseInt(s);// 将字符串转换为数字
String s2 = String.valueOf(i);// 将数字转换为字符串
```

2. String 与 char[]

```java
String s = "hello";
char[] chars = s.toCharArray();
String s1 = new String(chars);
```

3. String 与 byte[]

```java
String s = "hello";
byte[] bytes = s.getBytes(); // 使用默认的字符集进行转换
String s1 = new String(bytes);
```

#### StringBuffer



#### StringBuilder



### 日期时间 API

> 1. java.util.Date
> 2. java.sql.Date
> 3. System.currentTimeMillis
> 4. Calendar

#### JDK 8 之前



#### JDK 8 之后

### JAVA 比较器

### System 类

### Math 类

### BigInteger 与 BigDecimal

## Package

java 中的包（package）本质上就是磁盘上的目录，只不过在 java 中需要在项目（app 或 API）的 src 目录下建立相关的子目录（package），这些子目录才会被 java 视为包


